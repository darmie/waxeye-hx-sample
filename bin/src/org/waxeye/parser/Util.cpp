// Generated by Haxe 3.4.2 (git build master @ 890f8c7)
#include <hxcpp.h>

#ifndef INCLUDED_org_waxeye_parser_RawError
#include <org/waxeye/parser/RawError.h>
#endif
#ifndef INCLUDED_org_waxeye_parser_Util
#include <org/waxeye/parser/Util.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_2f47cabc55db5650_14_new,"org.waxeye.parser.Util","new",0x0e707362,"org.waxeye.parser.Util.new","org/waxeye/parser/Util.hx",14,0x128cea8d)
HX_LOCAL_STACK_FRAME(_hx_pos_2f47cabc55db5650_17_arrayPrepend,"org.waxeye.parser.Util","arrayPrepend",0x228c1333,"org.waxeye.parser.Util.arrayPrepend","org/waxeye/parser/Util.hx",17,0x128cea8d)
HX_LOCAL_STACK_FRAME(_hx_pos_2f47cabc55db5650_30_uniq,"org.waxeye.parser.Util","uniq",0x989bc93f,"org.waxeye.parser.Util.uniq","org/waxeye/parser/Util.hx",30,0x128cea8d)
HX_LOCAL_STACK_FRAME(_hx_pos_2f47cabc55db5650_44_getLineCol,"org.waxeye.parser.Util","getLineCol",0x2d64b7f4,"org.waxeye.parser.Util.getLineCol","org/waxeye/parser/Util.hx",44,0x128cea8d)
static const ::String _hx_array_data_115eda70_6[] = {
	HX_("\r",0d,00,00,00),HX_("\n",0a,00,00,00),
};
HX_LOCAL_STACK_FRAME(_hx_pos_2f47cabc55db5650_71_first,"org.waxeye.parser.Util","first",0x496a5fb2,"org.waxeye.parser.Util.first","org/waxeye/parser/Util.hx",71,0x128cea8d)
HX_LOCAL_STACK_FRAME(_hx_pos_2f47cabc55db5650_79_rest,"org.waxeye.parser.Util","rest",0x969959d2,"org.waxeye.parser.Util.rest","org/waxeye/parser/Util.hx",79,0x128cea8d)
HX_LOCAL_STACK_FRAME(_hx_pos_2f47cabc55db5650_90_updateError,"org.waxeye.parser.Util","updateError",0x3e9caa01,"org.waxeye.parser.Util.updateError","org/waxeye/parser/Util.hx",90,0x128cea8d)
namespace org{
namespace waxeye{
namespace parser{

void Util_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_2f47cabc55db5650_14_new)
            	}

Dynamic Util_obj::__CreateEmpty() { return new Util_obj; }

void *Util_obj::_hx_vtable = 0;

Dynamic Util_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Util_obj > _hx_result = new Util_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Util_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x6d812fa8;
}

 ::Dynamic Util_obj::arrayPrepend( ::Dynamic item, ::Dynamic a){
            	HX_STACKFRAME(&_hx_pos_2f47cabc55db5650_17_arrayPrepend)
HXLINE(  19)		if (hx::IsNotNull( a )) {
HXLINE(  21)			a = hx::TCast< ::cpp::VirtualArray >::cast(a)->slice((int)0,null());
            		}
HXLINE(  24)		hx::TCast< ::cpp::VirtualArray >::cast(a)->unshift(item);
HXLINE(  26)		return a;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Util_obj,arrayPrepend,return )

::cpp::VirtualArray Util_obj::uniq(::cpp::VirtualArray x){
            	HX_STACKFRAME(&_hx_pos_2f47cabc55db5650_30_uniq)
HXLINE(  32)		::cpp::VirtualArray r = ::cpp::VirtualArray_obj::__new(0);
HXLINE(  33)		{
HXLINE(  33)			int _g = (int)0;
HXDLIN(  33)			while((_g < x->get_length())){
HXLINE(  33)				 ::Dynamic e = x->__get(_g);
HXDLIN(  33)				_g = (_g + (int)1);
HXLINE(  35)				if ((r->indexOf(e,null()) == (int)-1)) {
HXLINE(  36)					r->push(e);
            				}
            			}
            		}
HXLINE(  39)		return r;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Util_obj,uniq,return )

::Array< int > Util_obj::getLineCol(int pos,::String input){
            	HX_STACKFRAME(&_hx_pos_2f47cabc55db5650_44_getLineCol)
HXLINE(  46)		int col = (int)0;
HXDLIN(  46)		int line = (int)0;
HXDLIN(  46)		int lastLineBreak = (int)0;
HXLINE(  48)		{
HXLINE(  48)			int _g1 = (int)0;
HXDLIN(  48)			int _g = pos;
HXDLIN(  48)			while((_g1 < _g)){
HXLINE(  48)				_g1 = (_g1 + (int)1);
HXDLIN(  48)				int i = (_g1 - (int)1);
HXLINE(  49)				bool _hx_tmp;
HXDLIN(  49)				if ((input.charAt(i) == HX_("\r",0d,00,00,00))) {
HXLINE(  49)					_hx_tmp = (input.charAt((i + (int)1)) == HX_("\n",0a,00,00,00));
            				}
            				else {
HXLINE(  49)					_hx_tmp = false;
            				}
HXDLIN(  49)				if (_hx_tmp) {
HXLINE(  50)					continue;
            				}
HXLINE(  53)				::Array< ::String > rn = ::Array_obj< ::String >::fromData( _hx_array_data_115eda70_6,2);
HXLINE(  55)				if ((rn->indexOf(input.charAt(i),null()) != (int)-1)) {
HXLINE(  57)					line = (line + (int)1);
HXLINE(  58)					lastLineBreak = (i + (int)1);
            				}
HXLINE(  61)				col = (i - lastLineBreak);
            			}
            		}
HXLINE(  64)		::Array< int > ret = ::Array_obj< int >::__new(0);
HXLINE(  65)		ret->push((line + (int)1));
HXLINE(  66)		ret->push(col);
HXLINE(  68)		return ret;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Util_obj,getLineCol,return )

 ::Dynamic Util_obj::first(::cpp::VirtualArray a){
            	HX_STACKFRAME(&_hx_pos_2f47cabc55db5650_71_first)
HXLINE(  72)		if (hx::IsNotNull( a )) {
HXLINE(  73)			return a->__get((int)0);
            		}
HXLINE(  76)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Util_obj,first,return )

 ::Dynamic Util_obj::rest(::cpp::VirtualArray a){
            	HX_STACKFRAME(&_hx_pos_2f47cabc55db5650_79_rest)
HXLINE(  80)		if (hx::IsNotNull( a )) {
HXLINE(  81)			return a->slice((int)1,null());
            		}
HXLINE(  84)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Util_obj,rest,return )

 ::org::waxeye::parser::RawError Util_obj::updateError( ::org::waxeye::parser::RawError err,int pos, ::Dynamic e){
            	HX_GC_STACKFRAME(&_hx_pos_2f47cabc55db5650_90_updateError)
HXDLIN(  90)		bool _hx_tmp;
HXDLIN(  90)		if (hx::IsNotNull( err )) {
HXDLIN(  90)			_hx_tmp = (pos > err->pos);
            		}
            		else {
HXDLIN(  90)			_hx_tmp = false;
            		}
HXDLIN(  90)		if (_hx_tmp) {
HXLINE(  92)			return  ::org::waxeye::parser::RawError_obj::__alloc( HX_CTX ,pos,::cpp::VirtualArray_obj::__new(1)->init(0,err->currentNT),::cpp::VirtualArray_obj::__new(1)->init(0,e),err->currentNT);
            		}
            		else {
HXLINE(  94)			bool _hx_tmp1;
HXDLIN(  94)			if (hx::IsNotNull( err )) {
HXLINE(  94)				_hx_tmp1 = (pos == err->pos);
            			}
            			else {
HXLINE(  94)				_hx_tmp1 = true;
            			}
HXDLIN(  94)			if (_hx_tmp1) {
HXLINE(  96)				if ((err->pos == (int)0)) {
HXLINE(  97)					err->pos = (int)0;
            				}
HXLINE( 100)				if (hx::IsNull( err->currentNT )) {
HXLINE( 101)					err->currentNT = HX_("",00,00,00,00);
            				}
HXLINE( 104)				if (hx::IsNull( err->nonterminals )) {
HXLINE( 105)					err->nonterminals = ::cpp::VirtualArray_obj::__new(0);
            				}
HXLINE( 108)				if (hx::IsNull( err->failedChars )) {
HXLINE( 109)					err->failedChars = ::cpp::VirtualArray_obj::__new(0);
            				}
HXLINE( 112)				int err1 = err->pos;
HXDLIN( 112)				::cpp::VirtualArray _hx_tmp2 = ( (::cpp::VirtualArray)(::org::waxeye::parser::Util_obj::arrayPrepend(err->currentNT,err->nonterminals)) );
HXDLIN( 112)				::cpp::VirtualArray _hx_tmp3 = ( (::cpp::VirtualArray)(::org::waxeye::parser::Util_obj::arrayPrepend(e,err->failedChars)) );
HXDLIN( 112)				return  ::org::waxeye::parser::RawError_obj::__alloc( HX_CTX ,err1,_hx_tmp2,_hx_tmp3,err->currentNT);
            			}
            			else {
HXLINE( 114)				return  ::org::waxeye::parser::RawError_obj::__alloc( HX_CTX ,err->pos,err->nonterminals,err->failedChars,err->currentNT);
            			}
            		}
HXLINE(  90)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Util_obj,updateError,return )


Util_obj::Util_obj()
{
}

bool Util_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"uniq") ) { outValue = uniq_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"rest") ) { outValue = rest_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"first") ) { outValue = first_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"getLineCol") ) { outValue = getLineCol_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"updateError") ) { outValue = updateError_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"arrayPrepend") ) { outValue = arrayPrepend_dyn(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *Util_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *Util_obj_sStaticStorageInfo = 0;
#endif

static void Util_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Util_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Util_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Util_obj::__mClass,"__mClass");
};

#endif

hx::Class Util_obj::__mClass;

static ::String Util_obj_sStaticFields[] = {
	HX_HCSTRING("arrayPrepend","\x75","\x26","\x40","\xe9"),
	HX_HCSTRING("uniq","\x81","\xca","\xa9","\x4d"),
	HX_HCSTRING("getLineCol","\xb6","\x16","\xf2","\x6e"),
	HX_HCSTRING("first","\x30","\x78","\x9d","\x00"),
	HX_HCSTRING("rest","\x14","\x5b","\xa7","\x4b"),
	HX_HCSTRING("updateError","\xff","\x34","\xc2","\x58"),
	::String(null())
};

void Util_obj::__register()
{
	hx::Object *dummy = new Util_obj;
	Util_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("org.waxeye.parser.Util","\x70","\xda","\x5e","\x11");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Util_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Util_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Util_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< Util_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Util_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Util_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Util_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace org
} // end namespace waxeye
} // end namespace parser
